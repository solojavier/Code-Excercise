Comentarios de implementacion

CodeExercise

La clase esta muy ligada a la posición en donde están   los archivos (hardcoded) que viene de los enums, considero esto como una mala idea en caso de algún cambio de requerimiento, siento que debería utilizar mas un poco de inyección de dependencias.
El archivo de salida  también no puede ser cambiado de forma dinámica, tal vez el requerimiento era así, pero insisto en que esto debería poder ser modificable.
Programación sobre interfaces no es utilizada en algunas referencias de listas.

FileScanner

El metodo getLines podría devolver un List para ayudar al principio de programación usando interfaces.
En general puede  que sea yo el sangrón pero siento que esta clase pudo quedar mejor diseñada, devolviendo una Lista de Listas de String con los valores del archivo sin tener que efectuar lo mismo en dos pasos por parte del cliente, así como también se podría haber hecho esto sin tener que crear un objeto por archivo (El atributo file es final por tanto no puede ser modificado en runtime si es que se quisiera poner un setter del nombre de archivo), y solamente pedir la lista de listas en un método.

InputFiles
Siento que esta clase es la que hace que todo lo demás sea tan estático y no tan dinámico. No siento que tenga mucho que decir al respecto.

Person
No entiendo muy bien porque el constructor lo tiene con acceso default, siento que esto es algo importante a notar.
Los comparadores siento que fue una buena idea para hacer el sorting utilizando el Collections.sort después, aunque siento que hubiera sido mejor si se hubiesen hecho en clases separadas y no como inner classes dentro de Person.
El arraylist que se mejoranda con los valores y la manera de sacar el order siento que no es tan natural.

Comentarios de testing

Tests:

CodeExerciseTest.

Siento que las pruebas no deberían de tocar el sistema de archivos, base de datos o cualquier otro recurso externo ah menos que fueran pruebas de integración, y en todo caso, el usuario debería de asegurarse que lo esperado viene dentro del paquete, al no tener los archivos que se necesitan para la prueba me sale un mensaje de error. En general siento que es mala practica hacer este tipo de pruebas con recursos externos en un unit test.

       FileScannerTest
 Hay dos variables de instancia declaradas que nunca son usadas. Por como están las pruebas se puede ver que FileScanner es un objeto que no puede ser modificado en runtime y que el path de los archivos en los enum están hardcoded y no pueden ser dinámicos, tal vez así haya sido el requerimiento pero considero que el diseño debería ser mas flexible para poder especificar rutas dinámicas.
Otra cosa que se me hizo interesante fue el ver que no utiliza interfaces en vez de clases concretas como nombre de referencia, lo digo por el ArrayList como parte de la referencia en las clases locales, ademas de que se están creando objetos que nunca son utilizados, un ejemplo:

 @Test
    public void testGetLinesCommaFile()   
    {
FileScanner commaFileScanner = new FileScanner(InputFiles.COMMA.getPath());
ArrayList<String> linero considero que el diseño debería ser mas flexible para poder especificar rutas dinámicas.
Otra cosa que se me hizo interesante fue el ver que nosertEquals(lines.get(1),"Bishop, Timothy, Male, Yellow, 4/23/1967");
assertEquals(lines.get(2),"Kelly, Sue, Female, Pink, 7/12/1959");
    }

    bien podría ser 

@Test
    public void testGetLinesCommaFile()   
      {
FileScanner commaFileScanner = new FileScanner(InputFiles.COMMA.getPathetPath());
ArrayList<String> lines = commaFileScanner.getLines();
          
assertEquals(lines.get(0),"Abercrombie, Neil, Male, Tan, 2/13/1943"Tan);
assertEquals(lines.get(1),"Bishop, Timothy, Male, Yellow, 4/23/1967");
assertEquals(lines.get(2),"Kelly, Sue, Female, Pink, 7/12/1959")12;
    }

Y eso trasladado a interfacen, 2/13/1943");
assertEquals(lineroes.get(1),"Bishop, Timothy, Male, Yellow, 4/23/1967");
assertEquals(linesines.get(2),"Kelly, Sue, Female, Pink, 7/12/1959");
    }

  Lo malo de nuevo de esta prueba es que depende de los recursos externos del sistema de archivos.

PersonTests
Mismo comentario acerca de programación sobre clases concretas.
Por los que se puede ver la clase Person no es un bean tan común, por la manera de llenado, igual pudo haber utilizado los setters que vienen en la clase Person dejando que el cliente construyera el objeto en vez de mandarle el arreglo y mandarse construir así mismo se me hace que se complica un poco la logica por esto mismo, aunque bueno también hay un constructor por default que puede servir para los mismos fines.
</String></String>


